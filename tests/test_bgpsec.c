/*
 * This file is part of RTRlib.
 *
 * This file is subject to the terms and conditions of the MIT license.
 * See the file LICENSE in the top level directory for more details.
 *
 * Website: http://rtrlib.realmv6.org/
 */

#include <assert.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include "rtrlib/bgpsec/bgpsec.h"
#include "rtrlib/spki/hashtable/ht-spkitable.h"

#ifdef BGPSEC

static struct spki_record *create_record(int ASN,
					 uint8_t *ski,
					 int spki_offset)
{
	u_int32_t i;
	struct spki_record *record = malloc(sizeof(struct spki_record));

	memset(record, 0, sizeof(*record));
	record->asn = ASN;
	memcpy(record->ski, ski, SKI_SIZE);

	for (i = 0; i < sizeof(record->spki) / sizeof(u_int32_t); i++)
		((u_int32_t *)record->spki)[i] = i + spki_offset;

	record->socket = NULL;
	return record;
}

static void init_structs(void)
{
	struct spki_table table;
	struct spki_record *record1;
	struct spki_record *record2;

	enum bgpsec_result result;
	int as_hops;

	// AS(64496)--->AS(65536)--->AS(65537)

	/*const unsigned char first_bytes_sequence[] = {*/
		/*0x00,0x01,0x00,0x00,	// target as (65536)*/
		/*0x01,			// pcount*/
		/*0x00,			// flags*/
		/*0x00,0x00,0xFB,0xF0,	// asn 64496*/
		/*0x01,			// algo id*/
		/*0x00,0x01,		// afi*/
		/*0x01,			// safi*/
		/*0x18,0xC0,0x00,0x02	// prefix 192.0.2.0/24*/
	/*};*/

	/*const unsigned char second_bytes_sequence[] = {*/
		/*0x00,0x01,0x00,0x01,	// target as (65537)*/
		/*0xAB,0x4D,0x91,0x0F,0x55, // ski (64496)*/
		/*0xCA,0xE7,0x1A,0x21,0x5E, //*/
		/*0xF3,0xCA,0xFE,0x3A,0xCC, //*/
		/*0x45,0xB5,0xEE,0xC1,0x54, //*/
		/*0x00,0x48,		// sig len*/
		/*0x30,0x46,0x02,0x21,0x00,0xEF,0xD4,0x8B,0x2A,0xAC,0xB6,0xA8,0xFD,0x11,0x40,0xDD, // sig*/
		/*0x9C,0xD4,0x5E,0x81,0xD6,0x9D,0x2C,0x87,0x7B,0x56,0xAA,0xF9,0x91,0xC3,0x4D,0x0E, //*/
		/*0xA8,0x4E,0xAF,0x37,0x16,0x02,0x21,0x00,0x8E,0x21,0xF6,0x0E,0x44,0xC6,0x06,0x6C, //*/
		/*0x8B,0x8A,0x95,0xA3,0xC0,0x9D,0x3A,0xD4,0x37,0x95,0x85,0xA2,0xD7,0x28,0xEE,0xAD, //*/
		/*0x07,0xA1,0x7E,0xD7,0xAA,0x05,0x5E,0xCA,					 //*/
		/*0x01,			// pcount*/
		/*0x00,			// flags*/
		/*0x00,0x01,0x00,0x00,	// asn 65536*/
		/*0x01,			// pcount*/
		/*0x00,			// flags*/
		/*0x00,0x00,0xFB,0xF0,	// asn 64496*/
		/*0x01,			// algo id*/
		/*0x00,0x01,		// afi*/
		/*0x01,			// safi*/
		/*0x18,0xC0,0x00,0x02	// prefix 192.0.2.0/24*/
	/*};*/

	/* The size in bytes of one signature_seg in this test case is:
	 * 10 * 1 (ski) +
	 * 2 (sig_len) +
	 * 5 * 1 (signature)
	 * -----------
	 * 17
	 */
	struct signature_seg *ss;

	/* The size in bytes of one secure_path_seg in this test case is:
	 * 1 (pcount) +
	 * 1 (conf_seg) +
	 * 4 (asn)
	 * -----------
	 * 6
	 */
	struct secure_path_seg *sps;

	/* The size in bytes of bgpsec_data in this test case is:
	 * 1 (alg_suite_id) +
	 * 2 (afi) +
	 * 1 (safi) +
	 * 2 * 1 (nlri)
	 * -----------
	 * 6
	 */
	struct bgpsec_data *bg;

	/* In total, the raw data that is processed by the validation
	 * function in this test case is:
	 * 2 * 17 (sig_segs)
	 * 2 * 6 (seg_path_segs)
	 * 6 (bgpsec_data)
	 * -----------
	 * 52
	 */

	/*const uint8_t ski1[]  = {*/
			 /*0x47,0xF2,0x3B,0xF1,0xAB,*/
			 /*0x2F,0x8A,0x9D,0x26,0x86,*/
			 /*0x4E,0xBB,0xD8,0xDF,0x27,*/
			 /*0x11,0xC7,0x44,0x06,0xEC*/
			/*};*/

	/*const uint8_t sig1[]  = {*/
			 /*0x30,0x46,0x02,0x21,0x00,0xEF,0xD4,0x8B,0x2A,0xAC,0xB6,0xA8,0xFD,0x11,0x40,0xDD,*/
			 /*0x9C,0xD4,0x5E,0x81,0xD6,0x9D,0x2C,0x87,0x7B,0x56,0xAA,0xF9,0x91,0xC3,0x4D,0x0E,*/
			 /*0xA8,0x4E,0xAF,0x37,0x16,0x02,0x21,0x00,0x90,0xF2,0xC1,0x29,0xAB,0xB2,0xF3,0x9B,*/
			 /*0x6A,0x07,0x96,0x3B,0xD5,0x55,0xA8,0x7A,0xB2,0xB7,0x33,0x3B,0x7B,0x91,0xF1,0x66,*/
			 /*0x8F,0xD8,0x61,0x8C,0x83,0xFA,0xC3,0xF1*/
			/*};*/

	const uint8_t ski2[]  = {
			 0xAB,0x4D,0x91,0x0F,0x55,
			 0xCA,0xE7,0x1A,0x21,0x5E,
			 0xF3,0xCA,0xFE,0x3A,0xCC,
			 0x45,0xB5,0xEE,0xC1,0x54
			};

	const uint8_t sig2[]  = {
			 0x30,0x46,0x02,0x21,0x00,0xEF,0xD4,0x8B,0x2A,0xAC,0xB6,0xA8,0xFD,0x11,0x40,0xDD,
			 0x9C,0xD4,0x5E,0x81,0xD6,0x9D,0x2C,0x87,0x7B,0x56,0xAA,0xF9,0x91,0xC3,0x4D,0x0E,
			 0xA8,0x4E,0xAF,0x37,0x16,0x02,0x21,0x00,0x8E,0x21,0xF6,0x0E,0x44,0xC6,0x06,0x6C,
			 0x8B,0x8A,0x95,0xA3,0xC0,0x9D,0x3A,0xD4,0x37,0x95,0x85,0xA2,0xD7,0x28,0xEE,0xAD,
			 0x07,0xA1,0x7E,0xD7,0xAA,0x05,0x5E,0xCA
			};

	/*const uint8_t pub_key2[] = {*/
			 /*0x30,0x59,0x30,0x13,0x06,0x07,0x2a,0x86,0x48,0xce,0x3d,0x02,0x01,0x06,0x08,0x2a,*/
			 /*0x86,0x48,0xce,0x3d,0x03,0x01,0x07,0x03,0x42,0x00,0x04,0x73,0x91,0xba,0xbb,0x92,*/
			 /*0xa0,0xcb,0x3b,0xe1,0x0e,0x59,0xb1,0x9e,0xbf,0xfb,0x21,0x4e,0x04,0xa9,0x1e,0x0c,*/
			 /*0xba,0x1b,0x13,0x9a,0x7d,0x38,0xd9,0x0f,0x77,0xe5,0x5a,0xa0,0x5b,0x8e,0x69,0x56,*/
			 /*0x78,0xe0,0xfa,0x16,0x90,0x4b,0x55,0xd9,0xd4,0xf5,0xc0,0xdf,0xc5,0x88,0x95,0xee,*/
			 /*0x50,0xbc,0x4f,0x75,0xd2,0x05,0xa2,0x5b,0xd3,0x6f,0xf5*/
			/*};*/
	
	// Resembles the prefix 192.0.2.0/24
	const uint8_t nlri[] = {
			 0x18,0xC0,0x00,0x02
			};

	// Allocate memory for the BGPsec data with two AS hops.
	as_hops = 1;
	ss = malloc(sizeof(struct signature_seg) * as_hops);
	sps = malloc(sizeof(struct secure_path_seg) * as_hops);
	bg = malloc(sizeof(struct bgpsec_data));

	// init the signature_seg and secure_path_seg structs.
	/*ss[0].ski		= &ski1;*/
	/*ss[0].sig_len		= 72;*/
	/*ss[0].signature		= &sig1;*/

	/*sps[0].pcount		= 1;*/
	/*sps[0].conf_seg		= 0;*/
	/*sps[0].asn		= 65536;*/

	ss[0].ski		= &ski2;
	ss[0].sig_len		= 72;
	ss[0].signature		= &sig2;

	sps[0].pcount		= 1;
	sps[0].conf_seg		= 0;
	sps[0].asn		= 64496;
	
	// init the bgpsec_data struct.
	bg->alg_suite_id	= 1;
	bg->afi			= 1;
	bg->safi		= 1;
	/*bg->asn			= 65537;*/
	bg->asn			= 65536;
	bg->nlri_len		= 4;
	bg->nlri		= &nlri;

	// init the SPKI table and store two router keys in it.
	spki_table_init(&table, NULL);
	/*record1 = create_record(65536, ski1, 0);*/
	record2 = create_record(64496, ski2, 1);

	/*spki_table_add_entry(&table, record1);*/
	spki_table_add_entry(&table, record2);

	// Pass all data to the validation function. The result is either
	// BGPSEC_VALID or BGPSEC_NOT_VALID.
	// Test with 2 AS hops.
	result = bgpsec_validate_as_path(bg, ss, sps, &table, as_hops);

	assert(result == BGPSEC_VALID);
	
	// Free all allocated memory.
	spki_table_free(&table);
	/*free(record1);*/
	free(record2);
	free(ss);
	free(sps);
	free(bg);
}

static void bgpsec_version_and_algorithms_test(void)
{
	// BGPsec version tests
	assert(bgpsec_get_version() == 0);

	assert(bgpsec_get_version() != 1);

	// BGPsec algorithm suite tests
	assert(bgpsec_check_algorithm_suite(1) == 0);

	assert(bgpsec_check_algorithm_suite(2) == 1);

	// BGPsec algorithm suites array test
	/*char *suites;*/
	/*int suites_len = bgpsec_get_algorithm_suites_arr(suites);*/
	/*for (int i = 0; i < suites_len; i++)*/
		/*assert(suites[i] == 1);*/
}



#endif

int main(void)
{
#ifdef BGPSEC
	bgpsec_version_and_algorithms_test();
	init_structs();
	printf("Test successful\n");
#endif
	return EXIT_SUCCESS;
}
